/*
	赋值运算符的特点:
		1.+=,-=,*=,/=,%= 运算符 如果最终的结果的数据类型和左侧变量的类型不一致,
			内部会帮助我们进行强制类型转换(隐藏的,我们看不见)
		
		2.整数常量只要不超过所赋值变量的取值范围,可以直接赋值,内部会隐藏进行强制类型转换		
*/
public class Demo15Operator {
	public static void main(String[] args){	
		/*
			右侧的数字1是int类型(占4个字节),而左侧的变量s是short类型(占2个字节)
			按照道理来讲,是不能把int类型数据,直接赋值给short变量的
			但是发现代码可以运行的,没有问题的
			原因:
				数字1是一个常量,而且没有超过short变量的取值范围,JVM内部会自动帮助我们
				把int类型的数字1,强制转换成short类型,砍掉左侧的两个字节的0
				
		*/
		short s = /*(short)*/1;
		System.out.println(s);
		
		/*	
			错误: 
			s是short类型(占2个字节),1是int类型(占4个字节),类型不一致,会发生自动类型转换
			把short类型的s,自动转换为int类型(左侧补充2个字节的0),s的大小仍然1
			short + int ==> int + int ==> int 结果是int类型,占4个字节,
			不能直接赋值给左侧的占用2个字节的short类型的变量s
			大萝卜不能直接放入小坑中
			解决方案:
				1.把左侧的坑变大(以前采用这种方式)
				2.把右侧的萝卜变小(目前使用强制类型转换)
		*/
		//s = s + 1;//编译失败
		/*
			+= 进行运算时,如果最终的结果的数据类型和左侧变量的类型不一致,
			内部会帮助我们进行强制类型转换(隐藏的,我们看不见)
		*/
		s += 1;//s = (short)(s + 1)
		
		System.out.println(s);
	}
}