//强制类型转换练习一
public class Demo08Convert {
	public static void main(String[] args){
		//short类型变量，内存中占2个字节 
		short s = 1;	
		/*	
			错误: 
			s是short类型(占2个字节),数字1默认是int类型(占4个字节),类型不一致,会发生自动类型转换
			把short类型的s(占2个字节),自动类型转换为int类型(占4个字节),左侧补充2个字节的0,数字大小仍然是1
			short类型的s: 00000000 00000001
			自动类型转换为int类型: 00000000 00000000 00000000 00000001
			short + int ==> int + int ==> int 结果是int类型(占4个字节),
			不能直接赋值给左侧的short类型变量s(占2个字节)
			
			大萝卜不能直接放入小坑中
			解决方案:
				1.把坑变大(以前采用这种方式)
				2.把萝卜变小(现在采用这种方式: 强制类型转换)
		*/
		//s = s + 1;
		
		/*	
			正确: 
			s是short类型(占2个字节),数字1默认是int类型(占4个字节),类型不一致,会发生自动类型转换
			把short类型的s(占2个字节),自动类型转换为int类型(占4个字节),左侧补充2个字节的0,数字大小仍然是1
			short类型的s: 00000000 00000001
			自动类型转换为int类型: 00000000 00000000 00000000 00000001
			short + int ==> int + int ==> int 结果是int类型(占4个字节),
			不能直接赋值给左侧的short类型变量s(占2个字节)
			
			但是对结果数据进行了强制类型转换,把int类型的结果,强制转换成short类型,砍掉左侧的两个字节的内容
			int类型的结果:
				00000000 00000000 00000000 00000010
			强制转换成short类型: 砍掉左侧的两个字节的内容,因为砍掉的都是0,数字大小不变
				00000000 00000010			
			
			大萝卜不能直接放入小坑中
			解决方案:
				1.把坑变大(以前采用这种方式)
				2.把萝卜变小(现在采用这种方式: 强制类型转换)
		*/
		
		s = (short)(s + 1);
		System.out.println(s);//2
		
	}
}